<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd"
     xml:lang="en">
  <head>
    <title>Information Center for ARM</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <link type="text/css" rel="stylesheet" media="all" href="file://$TOOLKIT_DIR$/doc/infocenter/style/ewic.css" />
  </head>
  <body>
  <div id="topbanner"></div>
  <div id="titlebanner_small">
    <h2>Information Center for ARM</h2>
  </div>
  <div class="breadcrumb"><a href="$TOOLKIT_DIR$/doc/infocenter/index.ENU.html">Information Center for ARM</a> | EXAMPLES</div>
  <div class="mainblock">
   <h2>Example description</h2>

   <pre>  <!--Insert readme.txt-->
<span style="font-family: monospace;">
	I2C EEPROM driver

	Example Description

This firmware provides a basic example of how to use the I2C firmware library and
an associate I2C EEPROM driver to communicate with an I2C EEPROM device (here the
example is interfacing with M24C64 EEPROM)

I2C peripheral is configured in Master transmitter during write operation and in
Master receiver during read operation from I2C EEPROM.

The peripheral used is I2C1 but can be configured by modifying the defines values
in stm324xg_eval.h (or stm324x7i_eval.h) file. The speed is set to 100kHz and can
be configured by modifying the relative define in stm324xg_eval_i2c_ee.h
(or stm324x7i_eval_i2c_ee.h) file.

For M24C64 devices all the memory is accessible through the two-bytes
addressing mode and need to define block addresses. In this case, only the physical
address has to be defined (according to the address pins (E0,E1 and E2) connection).
This address is defined in stm324xg_eval_i2c_ee.h (or stm324x7i_eval_i2c_ee.h)
(default is 0xA0: E0, E1 and E2 tied to ground).
The EEPROM addresses where the program start the write and the read operations
is defined in the main.c file.

First, the content of Tx1_Buffer is written to the EEPROM_WriteAddress1 and the
written data are read. The written and the read buffers data are then compared.
Following the read operation, the program waits that the EEPROM reverts to its
Standby state. A second write operation is, then, performed and this time, Tx2_Buffer
is written to EEPROM_WriteAddress2, which represents the address just after the last
written one in the first write. After completion of the second write operation, the
written data are read. The contents of the written and the read buffers are compared.

All transfers are managed in DMA mode (except when 1-byte read/write operation is
required). Once sEE_ReadBuffer() or sEE_WriteBuffer() function is called, the
use application may perform other tasks in parallel while Read/Write operation is
managed by DMA.

This example provides the possibility to use the STM324xG-EVAL (or STM32437I-EVAL)
LCD screen for messages display (transfer status: Ongoing, PASSED, FAILED).
To enable this option uncomment the define USE_LCD in the main.h file.


	Directory contents

  - I2C/I2C_EEPROM/system_stm32f4xx.c   STM32F4xx system clock configuration file
  - I2C/I2C_EEPROM/stm32f4xx_conf.h     Library Configuration file
  - I2C/I2C_EEPROM/stm32f4xx_it.c       Interrupt handlers
  - I2C/I2C_EEPROM/stm32f4xx_it.h       Interrupt handlers header file
  - I2C/I2C_EEPROM/main.c               Main program
  - I2C/I2C_EEPROM/main.h               Main program header file

 note The "system_stm32f4xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to your own configuration.
      To select different clock setup, use the "STM32F4xx_Clock_Configuration_V1.1.0.xls"
      provided with the AN3988 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment
  - This example runs on STM32F40xx/STM32F41xx, STM32F427x/STM32F437x Devices.

  - This example has been tested with STMicroelectronics STM324xG-EVAL (STM32F40xx/
    STM32F41xx Devices) and STM32437I-EVAL (STM32F427x/STM32F437x Devices) evaluation
    boards and can be easily tailored to any other supported device and development
    board.

  - STM324xG-EVAL and STM32437I-EVAL Set-up
    - Make sure the jumper JP24 "WP" is fitted on the board.
    - You may modify the timeout values "sEE_LONG_TIMEOUT" present in "stm324x7i_eval_i2c_ee.h"
      depending on CPU frequency and application conditions.


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F4xx_StdPeriph_Templates
 - Open your preferred toolchain
 - Add the "stm324xg_eval_i2c_ee.c" file (under Utilities\STM32_EVAL\STM3240_41_G_EVAL)
   or "stm324x7i_eval_i2c_ee.c" file (under Utilities\STM32_EVAL\STM324x7i_EVAL)
   to the project source list
 - Rebuild all files and load your image into target memory
 - Run the example


===============================================================================


	Example on how to use the IO Expander

	Example Description

  This firmware provides an example of configuring and using the IO Expander STMPE1600
  STMPE811 in order to control input Joystick IOs, output IOs and the Touch Screen
  feature. This example provides the elementary steps to control the following modules
  and use them in an application:
  The IO pins are used for:
    - Getting Joystick pins status (Polling and interrupt).
    - The Touch Screen controller is used to get the Touched area detection information
      in a single point mode (Polling and interrupt).

  The input information can be used either in Polling mode (uncomment the define
  #define IOE_POLLING_MODE) or in Interrupt mode (uncomment the define #define
  IOE_INTERRUPT_MODE). These defines are in main.h file.

  After configuring the IO Expander modules and Interrupts (if needed), the output
  IOs are set to their default state. If the IO Expander is not operational (or the
  I2C pins are not in the correct level), a message is displayed on the LCD screen.

  To get the status of an input:
    - Dedicated function is used for Joystick which returns a JOY_State_TypeDef
      value indicating the currently pressed key. This information is used to update
      the LCD display (the Joystick pressed key name is displayed).
    - Dedicated function is used for Touch Screen which returns a pointer to
      a structure holding the Touch Screen status (did a Touch Detection happened,
      X, Y, and Z positions). Only detection into the drawn rectangles areas is
      considered and used to update the LEDs status and LCD display (corresponding
      LED turned ON when its rectangle is touched, and the LED name is displayed on
      the LCD screen).

  Besides, the example checks the status of the other Push-Buttons implemented on
  the board (Tamper/Key and WakeUp push-buttons). They are checked in parallel
  with the IO Expander IOs and the LCD display and LEDs are updated according to
  the push buttons state.


	Directory contents

  - I2C/I2C_IOExpander/system_stm32f4xx.c     STM32F4xx system clock configuration file
  - I2C/I2C_IOExpander/stm32f4xx_conf.h       Library Configuration file
  - I2C/I2C_IOExpander/stm32f4xx_it.c         Interrupt handlers
  - I2C/I2C_IOExpander/stm32f4xx_it.h         Interrupt handlers header file
  - I2C/I2C_IOExpander/main.c                 Main program
  - I2C/I2C_IOExpander/main.h                 Main program header file

 note The "system_stm32f4xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to your own configuration.
      To select different clock setup, use the "STM32F4xx_Clock_Configuration_V1.1.0.xls"
      provided with the AN3988 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment

  - This example runs on STM32F429x/STM32F439x Devices.

  - This example has been tested with STMicroelectronics STM324x9I-EVAL (STM32F429x/
    STM32F439x Devices) evaluation boards and can be easily tailored to any other
    supported device and development board.


	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F4xx_StdPeriph_Templates
 - Open your preferred toolchain
 - Add the following file in the project source list
    - Utilities\STM32_EVAL\STM324x9I_EVAL\stm324x9i_eval_ioe16.c
    - Utilities\STM32_EVAL\STM324x9I_EVAL\stm324x9i_eval_ioe8.c
 - Rebuild all files and load your image into target memory
 - Run the example


===============================================================================


	Two boards I2C Communication: Data Exchange using DMA example

	Example Description

This is a typical example of how to use the I2C firmware library to ensure the
steps of an I2C communication between slave Receiver/Transmitter and master
Transmitter/Receiver using DMA.

- Hardware Description

To use this example, you need to load it on two STM32 boards (let's call them
Board A and Board B) then connect these two boards through I2C lines and GND.
In the firmware example uncomment the dedicated line in the main.h file to use
the I2C peripheral as STM32 Master device or as STM32 Slave.

*------------------------------------------------------------------------------*
|                BOARD A                                BOARD B                |
|         ____________________                   ____________________          |
|        |                    |                 |                    |         |
|        |                    |                 |                    |         |
|        |     __________     |                 |     __________     |         |
|        |    |I2C Master|____|_______SDA_______|____|I2C Slave |    |         |
|        |    |  Device  |____|_______SCL_______|____|  Device  |    |         |
|        |    |__________|    |                 |    |__________|    |         |
|        |  O LD1             |                 |  O LD1             |         |
|        |  O LD2     RESET   |                 |  O LD2     RESET   |         |
|        |  O LD3        _    |                 |  O LD3        _    |         |
|        |  O LD4       |_|   |                 |  O LD4       |_|   |         |
|        |                    |                 |                    |         |
|        |             GND O--|-----------------|--O GND             |         |
|        |____________________|                 |____________________|         |
|                                                                              |
|                                                                              |
*------------------------------------------------------------------------------*

- Software Description

This example requires two boards(Master and Slave)

  - Phase 1:
    In master board I2C peripheral is configured in Master Transmitter with DMA
    where in Slave board I2C peripheral is configured in Slave Receiver with DMA.
    The master will send Data to Slave according to the defined buffer size.

  - Phase 2:
    In master board I2C peripheral is configured in Master Receiver with DMA,
    where in Slave board I2C peripheral is configured in Slave Transmitter with
    DMA.
    Once the master has initiated the communication (Start condition), the slave
    will send the defined data in his TxBuffer to the master.

At the end of the data transfer, a data consistency check will be performed
in master and slave sides. In case of mismatch between sent and received data,
LED2, LED3 and LED4 are OFF. Otherwise LED2, LED3 and LED4 are ON.

 note As the data transfers is ensured by DMA, the TxBuffer size must be equal
  or greater than two bytes.

The File "I2C/I2C_TwoBoards/DataExchangeDMA/main.h" allows different possibilities
of configuration of this example:
  - Addressing mode : 7-bit or 10-bit
  - I2C speed: Fast mode or Standard mode

The SysTick is configured to generate an interrupt each 10ms. A dedicated counter
inside the SysTick ISR is used to toggle the LED1 each 100ms indicating that the
firmware is running.

A defined communication timeout is insuring that the application will not remain
stuck in case of I2C communication is corrupted.
You can adjust this timeout through the USER_TIMEOUT  define inside main.h file
depending on CPU frequency and application conditions (interrupts routines,
number of data to transfer, speed, CPU frequency...).
When a given operation is not finished within the defined timeout, a callback is
made to the function "TimeOut_UserCallback()", this function is used to manage
timeout communication failure. In this example, this callback implements a simple
infinite loop, but user can add his own implementation to manage timeout failure.


	Directory contents

  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/stm32f4xx_conf.h    Library Configuration file
  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/stm32f4xx_it.c      Interrupt handlers
  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/stm32f4xx_it.h      Interrupt handlers header file
  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/main.c              Main program
  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/main.h              Main Header file
  - I2C/I2C_TwoBoards/I2C_DataExchangeDMA/system_stm32f4xx.c  STM32F4xx system source file

 note The "system_stm32f4xx.c" is generated by an automatic clock configuration
      tool and can be easily customized to your own configuration.
      To select different clock setup, use the "STM32F4xx_Clock_Configuration_V1.1.0.xls"
      provided with the AN3988 package available on <a href="http://www.st.com">ST Website</a>


	Hardware and Software environment
  - This example runs on STM32F40xx/STM32F41xx, STM32F427x/STM32F437x Devices.

  - This example has been tested with STMicroelectronics STM324xG-EVAL (STM32F40xx/
    STM32F41xx Devices) and STM32437I-EVAL (STM32F427x/STM32F437x Devices) evaluation
    boards and can be easily tailored to any other supported device and development
    board.

  - STM324xG-EVAL and STM32437I-EVAL Set-up
    - Connect I2C1 Master SCL pin (PB.06) to I2C1 Slave SCL (PB.06)
    - Connect I2C1 Master SDA pin (PB.09) to I2C1 Slave SDA (PB.09)

    note
    - Pull-up resistors should be connected to I2C SCL and SDA Pins in case of
      other boards use.

	How to use it ?

In order to make the program work, you must do the following :
 - Copy all source files from this example folder to the template folder under
   Project\STM32F4xx_StdPeriph_Template
 - Open your preferred toolchain
 - Rebuild all files and load your image into target memory
 - Run the example

</span>
  </pre>
  </div>
  </body>
</html>

